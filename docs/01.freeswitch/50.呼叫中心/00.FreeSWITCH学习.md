---
title: FreeSWITCH学习
date: 2022-02-28 22:23:43
permalink: /pages/8b0cf6/
categories:
  - freeswitch
  - 呼叫中心
tags:
  - 
---

## PSTN与VoIP基础

- VoIP（Voice Over IP）：承载于IP网上的语音通信（网络电话）。
- PSTN（Public Switched Telephone Network）：公共交换电话网。

### PSTN起源与发展

>在漫长的通信历史长河中，PSTN以及电话交换技术的发展经历了很多阶段，如从直接控
>制到间接控制再到公共控制、从人工交换到自动交换、从点子交换到程控交换、从模拟到
>数字、从电路交换到分组交换、从“硬”交换到软交换。

#### 最早的电话网

第一次语音传输是苏格兰人亚历山大·贝尔（Alexander Granham Bell）在1876年用振铃电
路实现的。

振铃电路实现是没有电话号码的，通话用户之间必须由物理线路连接，同一时间只能一个
用户讲话。

#### 人工电话交换时代

交换机（[Switch](https://so.csdn.net/so/search?q=Switch&spm=1001.2101.3001.7020)，又称Exchange）的设备诞生了，线路大大减小。交换连续工作全部由人工
完成。

#### 自动电话交换时代

1889年到1891年期间，美国阿尔蒙·B·史端桥（Almon B Strowger）发明了步进式自动电话交
换机。属于“直接控制”方式。

以后，又出现了旋转式和升降式的交换机。采用“记发器”的部件来接收用户的拨号脉冲，属于
“间接控制”方式。

1919年，瑞典的电话工程师帕尔姆格伦和贝塔兰德发明了“纵横制连接器”。把控制器和话路器
分开。控制部分由标志器和记发器来完成。

#### 半电子交换机时代

控制部分引入了电子技术，而话路部分在较长的一段时间内仍采用机械触电。

#### 空分交换机时代

1965年5月，美国布尔系统的1号电子交换机（ESS No.1）问世了，这是世界上第一部开通使用
的程控电话交换机。当时的交换机话路部分还保留了机械触电，以“空分”方式工作，因此称为
空分交换机。交换的还是模拟信号。

#### 数字交换时代

20世纪60年代初以来，脉冲编码调制（PCM）技术成功地应用于传输系统中，它将“模拟”的信号
数字化，提高了通话质量、增加了传输距离，节约了许多线路成本。1970年，法国开通了世界上
第一部程控数字交换机E10，开始了数字交换的心时代。

#### 现代PSTN时代

随着技术的进步和通信要求的增加，世界上许许多多的交换机也需要相互通信，这些交换机之间
通过中继线（Trunk）相连，随着电子交换机和程控交换机的发展，便出现了现代意义的PSTN网
络。

20世纪70年代后期出现了蜂窝式移动电话（当移动电话小到可以拿到手里的时候就开始叫“手机”了
）系统，这是无线电话发展的里程碑。无限电话的出现，扩展了PSTN网络能力和范围，对PSTN网络
的影响及其深远。

专门用于移动电话交换的通信网络称为移动网，而原来的程控交换网则称为固定电话网，简称固网。
简单来说，移动网就是在普通固网上增加了许多基站（Base Station，可以简单理解为天线），并
增加了归属位置寄存器（Home Location Register，HLR）和拜访位置寄存器（Visitor Location
Register，VLR），以记录用户的位置（）、支持异地漫游等。移动交换中心称为MSC（Mobile Switch
Center）。

#### 下一代网络及VoIP时代

随着分组交换的成熟及英特网的发展，人们认识到了将原始的基于电路交换的语音网络与基于分组
交换的英特网络进行融合（即语音通信和数据通信相结合）的必要性，因此一个称为NGN（Next
Generation Network）的概念被提了出来。

经过数年的研究和探索，人们提出了各种NGN解决方案，但最终基本上都统一到了IMS（IP Multimedia
Subsystem）技术。

IMS属于核心交换层的技术，它全部基于IP网络，但在接入层，目前的语音大部分还是基于电路接入
的方式接入的，因此，在一定时间内IMS在接入层要继续兼容电路接入。未来的通信中要求完全取消
低效的电路传输及电路交换，而全部集中在IP通信上来，也就催生了新的无限通信标准LTE。

关于通信网络的演进，简单来说，在无线方面体现为从GSM/CDMA/UMTS等向LTE发展，在核心网方面则
体现为电路交换向IMS发展。

### 电话实现技术

#### 电话号码

1. 固定电话号码

   现行的电话网中采用E.164号码格式。

2. 移动电话号码和专用号段

   移动电话号码俗称手机号，由于其可移动与漫游的特性，与普通固定电话略有不同。我国的移动电话
   都是以1开头，按不同的运营商来划分。

3. 短号码

   有一类特殊的号码称为短号码，如110,119,120等。

4. 800和400号码

   800号码用手机打不通，400是可以手机呼叫的。

5. 北美电话号码分类计划

   加拿大和美国使用北美电话号码分类计划，其区号由3位数字组成，本地号码为7位数字，1为长途接入
   码，即长途字冠。

6. 电话号码书写格式

   国内号码的书写一般采用如下的方式：

   - (010)ABCD EFGH （没有国家代码，虽然0不是区号的一部分，但是，习惯了）
   - +86（10）ABCD EFGH （固话，8位，国际号码格式）
   - +86（10）ABCD EFGH （固话，8位，国际号码格式）
   - +86 139 ABCD EFGH （手机，国际号码格式）

#### 模拟信号与数字信号

模拟（Analog）量是连续的变化的量。容易引入噪音。

数字（Digital）信号是不连续的（离散的）。

####  PCM

PCM（Pulse Code Modulation）的全称是脉冲编码调制。它是一种通用的将模拟信号转换成以0和1表示
的数字信号的方法。

人的音频范围在300~3400Hz之间，通过滤波器将超过4000Hz的频率过滤出去，便得到4000Hz内的模拟信
号。然后根据抽样定理，使用8000Hz进行抽样，便得到离散的数字信号。使用PCM方法得到的数字信号
就称为PCM信号，一般一次抽样会得到16bit的信息。

使用压缩算法，可以将每一个抽样值压缩到8bit。这样1秒的抽样就得到8bit×8000=640000bit信号（简称
64kbit），抽样速率（即传输速率）为64Kbit/s。

PCM通常有两种压缩方式：A律和μ率。北美使用μ律，我国和欧洲使用A率。

#### 局间中继与电路复用技术

连接交换机（局）的E1或T1电路称为局间中继。

### 我国电话网结构

我国电话网由本地网与长途网组成，并通过国际交换中心进入国际电话网。

### 信令

用户设备（如话机）与端局交换机之间，以及交换机与交换机之间需要进行通信。这些通信所包含的信息有
（但不限于）用户、中继线状态、主叫号码、被叫号码、中继路由的选择等。我们把这些消息称为
信令（Signaling）。

#### 信令分类

按信令的功能分

- 线路信令：具有监视功能，用来监视主被叫的摘、挂机状态及设备忙闲。
- 路由信令：具有选择功能，指主叫所拨的被叫号码，用来选择路由
- 管理信令：具有操作功能，用于电话网的管理和维护。

按信令的工作区域分

- 用户线信令：是用户终端与交换机之间的信令。
- 局间信令：是交换机和交换机之间的信号，在局间中继线上传送，用来控制呼叫连续和拆线。

按信令的信道分

- 随路信令：信令和话音在同一条话路中传输。
- 公共信道信令：以时分方式在一条高速数据链路上传送一群话路。

其他分类

信令还可以分为带内信令和带外信令、模拟信令和数字信令、向前信令和向后信令、线路信令和记发器信令等。

#### 用户线信令

从用户终端（通常是话机）到端局交换机之间经常需要传送一些控制信息，如用户摘机、挂机、拨号、主叫号码
显示等，这些信息称为用户线信令。用户线信令可以通过模拟或数字信号传递。

#### 局间信令

交换机与交换机之间也需要传送控制信号，用于话路的建立、释放等，这些信号就称为局间信令。

目前在传统的PSTN网络中常见的局间信号有ISDN PRI（Primary Rate Interface，基群速率接口）信令和七号信令。
PRI信令和话路在同一个E1上传送。七号信令可以与话路在同一个E1上传送外，还可以在专门的用于传送信令链路的E1中继上传送。

#### 七号信令

七号信令（Signaling System No.7，SS7）是我国目前使用的主要信令方式，用于局间通信。我国的电话网络中有专
门的七号信令网。

由于ISUP（ISDN User Part，ISDN用户部分）能与ISDN互联并提供比TUP更多的能力和服务，故其已基本取代TUP成为我国七号信令网采用的主要信令方式。

#### H.323与SIP信令

H.323与SIP属于VoIP领域的通信信令，它们适用于用户线信令和局间信令。

H.323是ITU多媒体通信系列标准H.32x的一部分，该系列标准使得在现有通信网络上进行视频会议称为可能。

SIP（Session Initiation Protocol，会话发起协议）是由IETF（Interne 工程任务组）提出的IP电话信令协议。

### 媒体

信令主要传输一些控制信号，而通信双方需要听到的是对方的语音数据，这些语音数据就称为媒体（Media）.

在SIP通信中，除文字外，媒体都是在RTP协议中传输的。由于媒体一般都是持续传输的，因此又称RTP流。

### 电路交换与分组交换

传统电路交换，两个通信节点间需要建立一个专用通路。而报文交换以报文作为数据交换单位，携带目标地址、源地址等信息。分组交换是报文交换的特殊情形。

#### 电路交换

传统的电话都是基于电路交换的。

电路交换的优点：

- 由于通信线路为通信双方用户专用，数据直达，所以传输数据的时延性非常小。
- 通信双方之间的物理通路一旦建立，双方可以随时通信，实时性强。
- 双方通信时按发送顺序传输数据，不存在失序问题
- 电路交换既适用于传输模拟信号，又适用于传输数字信号。
- 进电路交换的设备（交换机等）及控制均较简单

电路交换的缺点：

- 电路交换的平均连接建立时间对计算机通信来说较长。
- 建立电路交换连接后，物理通路被通信双方独占，即使通信线路空闲，也不能供其他用户使用，因而通信利用率低。
- 在进行电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信，也难在通信过程中进行差错控制。

#### 分组交换

IP交换采用的就是分组交换方式。

分组交换的优点：

- 加快了数据在网络中的传输速度。
- 简化了存储管理。
- 减少了重发几率和重发数据量。
- 由于分组短小，更适用于采用优先级策略。

分组交换的缺点：

- 尽管分组交换比报文交换的传输时延少，但仍存在存储转发时延，而且节点交换机必须有更强的处理能力。
- 分组交换都要加上源、目的地址和分组编号，一定程度降低了通信效率，增加了处理时间，使控制复杂、
  时延增加。
- 分组到达目的节点时，要对分组按编号进行排序等工作，增加了麻烦。

### VoIP

IP电话（Voice over Internet Protocol，VoIP，又称宽带电话或网络电话）是一种透过互联网或其他使用
IP技术的网络来实现的新型电话通信。

目前，VoIP呼叫控制协议主要有SIP、H.323、MGCP与H.248/MEGACO等。

### IMS

#### 什么是IMS

IMS的全称是IP多媒体子系统（IP Multimedia Subsystem），它是一个基于IP网提供语音及多媒体的网络体系
架构。

#### IMS的特点

- 采用SIP作为呼叫控制协议。
- 支持Diameter协议。
- 采用归属控制方式。
- 采用接入无关性。
- 业务、控制、承载层完全分离。
- 增强计费功能。
- 增强多媒体业务。

#### IMS核心网元

1. **CSCF**

   CSCF（Call Sessoin Control Function，呼叫会话控制功能）。

   - 代理CSCF（P-CSCF）
   - 问询CSCF（I-CSCF）
   - 服务CSCF（S-CSCF）

2. **MGCF**

   MGCF（Media Gateway Control Function，媒体网关控制功能）

   - 控制IMS-MGW中的媒体信道的连接。
   - 与CSCF通信。
   - 根据路由号码，为从传统网络来的入局呼叫选择CSCF。
   - 执行ISUP协议和IMS呼叫控制协议间的转换。

3. **IM-MGW**

   IM-MGW（IP Multimedia-Media Gateway Function，多媒体网关功能）

   - 通过与MGCF交互来进行资源控制。
   - 拥有并维护回声消除器等资源。
   - 可能需要多媒体数字信号编、解码器。

4. **MRF**

   MRF（Multimedia Resource Function，多媒体资源功能）分成两部分，包括MRFC（Multimedia Resource Function Controller，多媒体资源功能控制器）和MRFP（Multimedia Resource Function Processor，多媒体资源功能处理器）。

5. **SLF**

   SLF（Subscription Locator Function，签约定位功能）

6. **HSS**

   HSS（Home Subscriber Server，归属用户服务功能）

7. **BGCF**

   BGCF（Breakout Gateway Control Function，出口网关控制功能）

8. **SGW**

   SGW（Singnalling Gateway Function，信令网关功能）

9. **AS**

   AS（Application Server，应用服务器）

## PSTN、PBX及呼叫中心业务

###  PSTN业务

PSTN除了为用户提供基本的语音通话外，还能提供一些附加的业务，如叫醒业务、呼叫转移等。

#### POTS

POTS（Plain Old Telephone Service）及普通老式电话业务。

#### 商务业务

- **模拟中继线**
- **数字中继线**
- **虚拟网**
- **立即计费**
- **VPN**

#### 其他增值业务

包括预付费业务（电话卡类业务等）、800业务、400业务以及彩铃、电话秘书台等。

### PBX业务

PBX（Private Branch eXchange）的全称是专用小交换机。

#### 呼叫转移

#### 同组代答

#### PBX与中继线

用户或企业PBX要想打通外面的电话，或者外面的电话需要打进来，需要走运营商提供的中继线，
以接入到PSTN网上。

### IP-PBX业务

FreeSWITCH的默认配置就是一个家用或小型企业级PBX，它是由纯软件实现的，基于IP网进行通信，
因而又称为IP-PBX。

IP-PBX首先是一个PBX（Private Branch eXchange），它具有传统PBX的绝大部分功能。另外，由于
使用了IP通信，它能够通过IP网提供语音、视频以及即时消息通信。

### 呼叫中心

基于企业级的PBX和IP-PBX的通信还只是局限于基础的通信层。而随着企业规模的扩大以及用户对服务
要求的提高，企业需要在业务层和管理层方面为用户提供更好的服务。当这些服务可以通过远程电话
支持的方式解决的情况下，一种称为呼叫中心的业务（Call Center）便产生了。

#### 什么是呼叫中心

呼叫中心又称客户服务中心，它是一种基于CTI技术、充分利用通信网和计算机网的多项功能集成，并
与企业连为一体的一个完整的综合信息服务系统，利用现有的各种先进的通信手段，高效的为客户提供
高质量、高效率、全方位的服务。

通俗的将，呼叫中心是企业或机构建立的以电话为主的主要手段，为客户提供服务于沟通的部门组织及
信息系统。

#### 呼叫中心的历史

1. **第一代呼叫中心**

   PBX基础上增加电话排队。

2. **第二代呼叫中心**

   IVR（Interactive Voice Response，交互式语音应答）系统的使用。

3. **第三代呼叫中心**

   CTI（Computor Telephony Integration，计算机电话集成）技术的应用。

4. **第四代呼叫中心**

   多媒体呼叫中心或联络中心（Contact Center）。

5. **下一代呼叫中心**

   融入互联网技术的媒体渠道与沟通渠道。

#### 呼叫中心的分类

按照呼叫中心系统采用的技术架构的不同，呼叫中心可以分为交换机、板卡、软交换（IPCC）三种类型。

#### 呼叫中心的主要技术指标

常见的KPI指标有接通率、呼入项目占有率、呼出项目工作效率、服务水品、客户满意度、平均振铃次数、
监听合格率、一次性解决问题率等。

#### CTI中间件

交换机设备厂商开始考虑为交换机增加一个可以受计算机系统控制的接口，有计算机系统通过某种协议
获取交换机用户话机的状态信息以及对呼叫的控制命令。这种连接和控制接口称为CTI-Link。

CTI中间件在下层通过对各种CTI-Link协议的包装和抽象，屏蔽了各种交换机的不同，在上层为呼叫中心
业务软件开发人员提供统一的API开发接口。

#### FreeSWITCH在呼叫中心的应用

- **语音交换功能**
- **媒体处理功能**
- **媒体监播功能**
- **电话会议功能**
- **电子传真功能**
- **排队功能**

## 初识FreeSWITCH

### 什么是FreeSWITCH

#### FreeSWITCH的概念

FreeSWITCH是一个开源的电话交换平台。官方给它的定义是–世界上第一个跨平台的、伸缩性极好的、免费
的、多协议的电话软交换平台。

####  FreeSWITCH的功能

典型功能：

- 在线计费、预付费功能
- 电话路由服务器
- 语音转码服务器
- 支持资源优先权和QoS的服务器
- 多点会议服务器
- IVR、语音通知服务器
- VoiceMail服务器
- PBX应用和软交换
- 应用层网关
- 防火墙/NAT穿越应用
- 私有服务器
- 第三方呼叫控制应用
- 业务生成环境运行时引擎
- 会话边界控制器
- IMS中的S-CSCF/P-CSCF/I-CSCF
- SIP网间互联网关
- SBC及安全网关
- 传真服务器、T.30到T.38网关

### 快速体验

#### 安装基本的FreeSWITCH系统

FreeSWITCH支持Linux、Windows、Mac平台。

1. 版本简介

   FreeSWITCH的版本号很有规律：版本号有3部分，以点号隔开。其中第1位为主版本，第2位为次版本，第3位作补丁及
   更新标志。其中，从第2位看，偶数的版本为稳定版，奇数版本为开发版。

2. 在linux上安装

   ![freeswitch安装文档]https://docs.ddoogg.cn/pages/a61298/#_3-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE

#### 连接SIP电话

reeSWITCH最典型的应用是作为一个服务器，并用电话客户端软件连接到它。

FreeSWITCH主要使用的通信协议是SIP。

支持SIP的软电话常用的有X-Lite和Zoiper。

X-Lite配置：

选“Sip Account Setting…”，单击“Add”添加一个账号，填入一下参数：

```yaml
Display Name:1000
User Name:1000
Password:1234
Authorization user name:1000
Domain:FreeSWITCH服务所在的IP地址
```

#### 配置FreeSWITCH

FreeSWITCH配置文件默认放在conf/下。

| conf/目录和文件    | **说明**                                                  |
| ------------------ | --------------------------------------------------------- |
| –vars.xml          | 一些常用变量                                              |
| –switch.xml        | 主配置文件，它会使用include语句装入其他文件               |
| –autoload_configs  | 目录，存放自动加载的配置文件                              |
| —-modules.conf.xml | 配置当FreeSWITCH启动时自动装载哪些模块                    |
| —-*.xml            | 一般来说每个模块都有一个配置文件                          |
| –chatplan          | 聊天计划                                                  |
| –dialplan          | 拨号计划                                                  |
| —-default.xml      | 默认的拨号计划配置，一般用于内部用户路由                  |
| —-public.xml       | 默认的拨号计划配置，一般用于外部来的路由                  |
| –drectory          | 用户目录                                                  |
| —-default          | 默认的用户目录配置                                        |
| ——*.xml            | SIP用户，每用户一个文件                                   |
| –ivr_menus         | IVR菜单                                                   |
| –jingle_profiles   | 连接Google Talk的相关配置                                 |
| –lang              | 多语言支持                                                |
| —-en               | 英语                                                      |
| —-fr               | 法语                                                      |
| –mrcp_profiles     | MRCP的相关配置，用于跟第三方语音合成和语音识别系统对接    |
| –sip_profiles      | SIP配置文件                                               |
| —-internal.xml     | 一个SIP profile，或称作一个SIP-UA，监听在本地IP及端口5060 |
|                    | 一般供内网用户使用                                        |
| —-externa.xml      | 另一个SIP-UA，用作外部连接，端口5080                      |
| –skinny_profiles   | 思科SCCP协议话机的配置文件                                |

FreeSWITCH默认设置了20个用户，如果你需要更多的用户，3步：

1. 在`conf/directory/default/`中增加一个配置文件。
2. 修改拨号计划使其他用户可以呼叫到它。
3. 重新加载配置文件使其生效。

#### FreeSWITCH用作软电话

也可以把FreeSWITCH简单地用作一个软电话。目前唯一支持CELT高清通话的软电话。

FreeSWITCH使用mod_portaudio模块支持你本地的音频设备，默认是不编译的。在源码目录执行：

```
make mod_portaudio
make mod_portaudio-install
```

安装完成后控制台执行：

```
load mod_portaudio
```

尝试以下命令：

```
pa looptest         （回路测试，echo）
pa call 9196        （呼叫9196）        
pa call 1000        （呼叫1000）
pa hangup           （挂机）
```

> 没成功
>
> make mod_portaudio
>
> Makefile:967: *** You must install portaudio19-dev to build mod_portaudio.  Sto

#### 配置SIP网关拨打外部电话

如果你拥有某个运营商提供的SIP账号，那么你就可以通过配置SIP来拨打外部电话了。
该SIP账号（或提供该账号的设备）在FreeSWITCH中称为SIP网关（Gateway）。

添加网关需要在`conf/sip_profiles/external/`中创建一个XML文件。如gwl.xml:

```xml
<gateway name="gwl">
    <param name="realm" value="SIP服务器地址，可以是IP或IP:端口号"/>
    <param name="username" value="SIP用户名"/>
    <param name="password" value="密码"/>
</gateway>
```

执行命令使之生效：

```shell
sofia profile external rescan
```

显示网关注册状态：

```shell
sofia status
```

如果显示`gateway gwl`的状态是`REGED`,则表明已正确地注册到了网关上。

先用命令试一下网关是否正常：

```xml
originate sofia/gateway/gwl/xxxxxx &echo
```

该命令会通过网关gwl呼叫号码xxxxxx，被叫号码接听电话后，FreeSWITCH会执行echo程序，
就能听到自己的回音了。

##### 从某一分机上呼出

常见的PBX一般是内部拨小号，打外部电话就需要加拨0或先按9。

```xml
<include>
    <extension name="call out">
        <condition field="destination_number" expression="^0(\d+)$">
            <action application="bridge" data="sofia/gateway/gwl/$1" />
        </condition>
    </extension>
</include>
```

其中，匹配0后面的变量并存入到变量$1中。然后通过bridge程序通过网关gwl打出该号码。

##### 呼入电话处理

一般来说，呼入的DID就是你的SIP号码。

创建XML文件放到`conf/dialplan/public/my_did.xml`中：

```xml
<include>
    <extension name="public_did">
        <condition field="destination_number" expression="^(你的DID)$">
            <action application="transfer" data="1000 XML default"/>
        </condition>
    </extension>
</include>
```

## 运行FreeSWITCH

### 命令行参数

一般来讲，FreeSWITCH不需要任何命令行参数就可以启动。

使用`freeswitch -h`或`freeswitch -help`或`freeswitch --help`显示帮助信息

常用的两个：

```shell
freeswitch -nc              #后台启动
freeswitch -nonat           #关掉NAT启动
```

### 系统启动脚本

在真正生成系统上，一般需要FreeSWITCH能跟系统一起启动。
- 在UNIX类系统上，启动脚本一般放在etc/init.d/下。可以在源码目录下找到不同系统启动脚本debian/freeswitch.init及build/freeswitch.init.*。
- 在Windows上，可以将FreeSWITCH注册为服务。

### 判断FreeSWITCH是否运行

UNIX类系统下：

1. 看进程是否存在。

   ```shell
   ps aux | grep freeswitch
   ```

2. 看相关端口是否被占用。

   ```sehll
   netstat -an | grep 5060
   netstat -anp | grep 5060
   ```

Windows平台：

netstat命令、任务管理器。

### 控制台与命令客户端

系统不带参数启动到控制台，在控制台上可以输入各种命令以控制或查询FreeSWITCH的状态。

```sql
version         -- 显示当前版本
status          -- 显示当前状态   
sofia status    -- 显示sofia状态
help            -- 显示帮助
```

为了调试方便，还在conf/autoload_configs/switch.conf.xml中定义了一些控制台快捷键。

FreeSWITCH是一个典型的Client/Server结构，不管FreeSWITCH运行在前台还是后台，你都可以使
用客户端软件fs_cli连接FreeSWITCH。

fs_cli使用FreeSWITCH的ESL协议与FreeSWITCH通信。

fs_cli也支持很多命令行参数，值得一提的是-x参数，它允许执行一条命令后退出。

```shell
$ bin/fs_cli -x "version"                                  # 显示版本号
$ bin/fs_cli -x "status"                                   # 显示状态
$ bin/fs_cli -x "originate user/1000 &bridge(user/1001)"       # 回拨
```

fs_cli可以连接到其他机器上的FreeSWITCH，用户主目录编辑配置文件`.fs_cli_conf`

```shell
[server1]
host        =>  192.168.1.10
port        =>  8021
password    =>  secret_password
debug       =>  7

[server2]
host        =>  192.168.1.11
port        =>  8021
password    =>  secret_password
debug       =>  0
```

配置好，可以这样使用：

```shell
$ fs_cli server1
$ fs_cli server2
```

fs_cli有几个特殊命令，以”/”开头。这些命令不直接发送到FreeSWITCH，而是先由fs_cli处理。

### 呼叫

#### 发起呼叫

使用`originate`命令发起一次呼叫。

```shell
freeswitch> originate user/1000 &echo
```

呼叫1000,1000接听后，将听到回声。

#### 呼叫字符串

“user/1000”称为呼叫字符串。

假设alice的UA地址为192.168.4.4:5090，已向FreeSWITCH注册。

```shell
freeswitch> sofia status profile internal reg
```

可以看到alice的注册信息。

使用originate命令呼叫user/alice这个呼叫字符串时，会找到Cantact地址`sip:alice@192.168.4.4:5090`并向其发送INVITE请求

#### API与App

FreeSWITCH的命令不仅可以在控制台上使用，也可以在各种嵌入式脚本、Event Socket或HTTP RPC上使用，
所有命令都遵循一个抽象的接口，因而这些命令又称为API Commands。

echo则是一个常用的应用程序（Application，App），它的作用是控制一个Channel的一端。
alice是一端，另一端是echo。这种通话称为“单腿通话（one-legged connection）”。

可以将电话“挂起”，park便是实现这个功能。

hold比较友好，等待同时播放音乐。

```shell
freeswitch> originate user/alice &hold
```

播放特定的声音

```shell
freeswitch> originate user/alice &playback(/root/welcome.wav)
```

或直接录音

```shell
freeswitch> originate user/alice &record(/tmp/voice_of_alice.wav)
```

大多数情况下，FreeSWITCH都是作为一个B2BUA来桥接两个UA进行通话的。在alice接听电话后，bridge程序可以在启动一个UA呼叫bob

```shell
freeswitch> originate user/alice &brige(user/bob)
```

另一种方式

```shell
originate user/alice &park
originate user/bob &park
show channels
uuid_bridge <alice_uuid><bob_uuid>
```

分别呼叫alice和bob，然后通过uuid_bridge命令将两个Channel桥接起来

两条命令（API）：originate和uuid_bridge
几个程序（App）：echo、park和bridge

>**简单来说，一个App是一个程序（Application），它作为一个Channel一端与另一端的UA进行通信，相当于它工作在Channel内部；
>而一个API则是独立于一个Channel之外的，它只能通过找到Channel的UUID来控制一个Channel（如果需要的话），相当于一个第三者。**
>这就是API和App最本质的区别。

- 大部分API都是在mod_commands模块中加载的。
- App则在mod_dptools中。

#### API命名帮助

使用help可以列出所有命令的帮助信息。

```shell
freeswitch> help
```

## FreeSWITCH架构

### 总体架构

总的来说，FreeSWITCH由一个稳定的核心（Core）以及一些外围模块组成。

FreeSWITCH内部使用线程模型来处理并发请求，每个连接都在单独的线程中进行处理，不同的线程间通过Mutex互斥访问共享资源，并
通过消息和异步事件等方式进行通信。

FreeSWITCH的核心非常短小精悍。绝大多数应用层的功能都在外围模块中实现。外围模块通过核心提供的Public API与核心进行通信，
而核心则通过回调（或称钩子）机制执行外围模块中的代码。

#### 核心

FreeSWITCH的核心是Core，它包含了关键的数据结构和复杂的代码、状态机、数据库等，这些代码只出现在核心中，并保持了最大限度的抽象和重用。外围模块只能通过核心代码提供的公共应用程序接口调用核心的功能。

1. 1.数据库（DB）

   FreeSWITCH的核心除了使用内部队列、哈希表存储数据外，也使用外部的关系型数据库存储数据。

2. 公共应用程序接口（Public API）

   核心层实现了一些Public API。这些Public API可以被外围的模块调用。

3. 接口（Interface）

   提供了很多抽象的接口，具体实现一般由外围的模块负责，核心层通过回调（钩子）方式调用具体的实现代码或函数。

4. 事件（Event）

   内部也使用消息和事件机制进行进程间和模块间通信。

#### 接口实现

接口都是抽象的，其中只有少量在核心中有具体实现（如PCM编码解码实现），大部分最终由外部实现。

- 终点（Endpoint）。
- 拨号计划（Dialplan）。
- 聊天计划（Chatplan）。
- 应用程序（Application，APP）。
- 命令接口（FSAPI）。
- XML接口（XML Interface）。
- 编解码器（Codec）。
- 语音识别及语音合成（ASR/TTS）。
- 格式、文件接口（Format、File Interface）。
- 日志（Logger）。
- 定时器（Timer）。
- 嵌入式语言（Embeded Language）。
- 事件套接字（Event Socket）。

### 目录结构

| 目录       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| bin        | 可执行程序                                                   |
| db         | 系统数据库（sqlite），将呼叫信息存放到数据库中，这样在查询时就无须对核心数据结构进行加锁了 |
| htdocs     | HTTP Server根目录                                            |
| lib        | 库文件                                                       |
| mod        | 可加载模块                                                   |
| run        | 运行目录，存放FreeSWITCH运行时PID                            |
| sounds     | 声音文件，使用playback()时默认的寻找路径                     |
| grammer    | 语法，用于ASR                                                |
| include    | 头文件                                                       |
| recordings | 录音，使用record()时默认的存放路径                           |
| scripts    | 嵌入式语言写的脚本，如使用lua()、luarun()、jsrun等默认寻找的路劲 |
| storage    | 语音留言（Voicemail）的录音                                  |
| conf       | 配置文件                                                     |

### 配置文件

在系统装载时，XML解析器会将所有的XML文件组织在一起，并读入内存，组成一个大的XML文档（Document），称为XML注册表。

#### freeswitch.xml

freeswitch.xml是所有XML文件的黏合剂。

#### vars.xml

vars.xml主要通过X-PRE-PROCESS指令定义了一些全局变量。如

```shell
<X-PRE-PROCESS cmd="set" data="domain=$${local_ip_v4}"/>
<X-PRE-PROCESS cmd="set" data="domain_name=$${domain}"/>
<X-PRE-PROCESS cmd="set" data="hold_music=local_stream://moh"/>
<X-PRE-PROCESS cmd="set" data="use_profile=internal"/>
```

实际使用中，可以使用global_getvar或API命令来查看这些变量的值。

```shell
freeswitch> global_getvar sound_prefix
freeswitch> global_getvar local_ip_v4
```

#### autoload_configs目录

autoload_config目录下的各种配置文件会在系统启动时装入。一般来说都是块级的配置文件，每个模块对应一个。

#### 其他

- dialplan目录：该目录定义了XML拨号计划。
- ivr_menues目录：该目录下存放了默认的一些IVR菜单例子。
- directory目录：作为注册服务器时，用于配置本地用户，配置信息称为用户目录。

### XML用户目录

SIP并不要求一定要注册才能可以打电话，但是通话前的用户认证参数仍需要在用户目录中进行配置。

### 呼叫相关概念

#### 来去话、Session、Channel与Call

Bob到FreeSWITCH的通话称为来话，FreeSWITCH作为一个B2BUA再去呼叫Alice时，称为去话。

无论来话还是却话，都会启动一个Session，控制着整个呼叫，直到结束。每个Session都控制着一个Channel。
在逻辑上组成一个通话，称为Call。

#### 回铃音与Early Media

A-交换机a-交换机b-B

为了在A端能听到B端特殊的回铃音，回铃音只能由B端交换机发送。这些回铃音称为Early Media。

理论上将，B接听电话后交换机b可以一直不向交换机a发送应答消息，而是将真正的话音数据伪装成Early Media，实现“免费通话”。

#### 全局变量与局部变量

- 全局变量 $${var}
- 局部变量 ${var}

- 局部变量 ${var}

## 拨号计划

拨号计划主要作用就是对电话进行路由，决定和影响通话的流程。

### 简单测试

1. 默认配置文件位置

   /usr/local/freeswitch/conf/dialplan

2. 默认配置文件

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220228163934.png)

3. 增加一个简单的配置,测试的案例最好放在配置的前面

   \#vi /usr/local/freeswitch/conf/dialplan/default.xml

```xml
<extension name="My Echo Test">
  <condition field="destination_number" expression="^echo|1234$"/>
  <action application="answer" data=""/>
  <action application="echo" data=""/>
  </condition>
</extension>
```

4. 控制台命令，生效配置文件

   ```shell
   reloadxml 或者F6
   console loglevel debug 或则F8
   ```

### XMLDialplan

可以是静态配置的，也可以使用动态配置方式从其他服务器或脚本中动态获取。

#### 配置文件的结构

拨号计划由多个Context组成。每个Context中有多个Extension。Context就是多个Extension的逻辑集合，
它相当于一个分组。一个Context中的Extension与其他Context中的Extension在逻辑上是隔离的。

#### 默认的配置文件简介

系统默认提供的配置文件包含三个Context，分别是default、feature和public。

- default：默认的Dialplan，一般来说注册用户都可以通过它来打电话。
- public：一般用于接收外来呼叫。外部来的呼叫是不可信的，要求更严格的控制
- 在 `default` 和 `public`配置文件中可以引用对应目录default和public中的.xml文件

#### 正则表达式

使用与Perl兼容的正则表达式匹配算法。

正则表达式的例子及说明：

| 例子           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| ^1234$         | "^"配字符中的开头,“$”配字符串的结尾所以本表达式严格匹配1234  |
| ^1234\|5678$   | "\|"是或的意思,表示匹配1234或5678                            |
| ^123[0-9]$     | "[]"表示配其中的任意一个字符,其中"-"表示一个区间,即0到9它等于[0123456789],也就是说它会匹配1230,1231,1232...1239 |
| ^123\d$        | 同上,d等于[0-9]                                              |
| ^123\d+$       | "+"号表示匹配1个或多个它前面的字符,这里由于"+"前面是"\d",所以它就等于1个或多个数字,实际上它匹配任意以123开头的至少4位数的数字,如1230，12300，12311，123456789等 |
| ^123\d*$       | "*"号与“+”号的不同在于,它匹配0个或多个面的字符,所以,它配以123开头至少3位数的数字,如123,123789 |
| ^123           | 跟上面一样,由于没有结尾的S,它匹配任何以123开头的数字申,但除此之开,它还匹配后面是字母的情况,如123abc |
| 123$           | 匹配任何以123结尾的字符                                      |
| ^123\d{5}$     | {5}表示精确匹配5位,包含它前面的字符,在这里,宅匹配以123开头的所有8位电话号码 |
| ^123(\d+)$     | "()"在匹配中不起作用,因而此处^123\d+$是相同的;但它对匹配结果有作用,匹配结果中除123之外的数字都将储在S1这个变量中,在后面可以引用 |
| ^123(\d)(\d+)$ | 果用它跟12345678匹配,则匹配成功,结果是$1=4,$2=5678           |
| .              | 最后说明,"."匹配任意一个字符,如果你写了“.*”,则它会匹配任意字符 |



#### 通道变量

每一次呼叫都由一条或多条“腿”（Call Leg）组成，其中的一条腿又称为一个Channel，每一个Channel都有很多属性，用于标识Channel的状态、性能等，这些属性称为Channel Variable（通道变量）。

查看通道变量

```xml
    <extension name="Show Channel Variable">
        <condition field="destination_number" expression="^1235|info$">
                <action application="info" data=""/>
        </condition>
    </extension>
```

使用通道变量

```xml
    <extension name="Accessing Channel Variable">
        <condition field="destination_number" expression="^1236(\d+)$">
                <action application="log" data="INFO Hahaha, i know you challed ${destination_number}"/>
                <action application="log" data="NOTICE, The Last few digits is $1 "/>
                <action application="log" data="ERR, this is not actually an error, just jocking :), have fun! "/>
                <action application="hangup" />
        </condition>
    </extension>
```

拨打1236789测试

info中显示的变量与通道变量的对应关系

[]: https://freeswitch.org/confluence/display/FREESWITCH/Channel+Variables

#### 测试条件

最简单的测试条件

```xml
<condition field="destination_number" expression="^1234$">
<condition field="network_addr" expression="^192\.168\.7\.7$">
```

Dialplan中的测试条件

| 变量               | 说明                                                      |
| ------------------ | --------------------------------------------------------- |
| context            | Dialplan当前的Context                                     |
| rdnis              | 被转移的号码                                              |
| destination_number | 被叫号码                                                  |
| diaplan            | Dialplan模块的名字，如XML、YAML、inline、asterisk、enum等 |
| caller_id_name     | 主叫（来电显示）的名称                                    |
| caller_id_number   | 主叫号码                                                  |
| ani                | 主叫的自动识别                                            |
| aniii              | 主叫类型，如投币电话                                      |
| uuid               | 本Channel的唯一标志                                       |
| source             | 呼叫源，来自哪一个FreeSWITCH模块                          |
| chan_name          | Channel名字                                               |
| network_addr       | 主叫ip地址                                                |
| year               | 当前的年，0~9999                                          |
| yday               | 一年中的第几天，1~366                                     |
| mon                | 月，1~12                                                  |
| mday               | 日，1~31                                                  |
| week               | 一年中的第几周，1~53                                      |
| mweek              | 本月中的第几周，1~6                                       |
| wday               | 一周中的第几天，1~7                                       |
| hour               | 小时，0~23                                                |
| minute             | 分，0~59                                                  |
| minute-of-day      | 一天中的第几分钟，（1~1440）                              |

接受用户在用户目录中设置的变量，但要注意必须使用${}对变量进行引用。

```shell
<condition field="${toll_allow}" expression="international">
```

测试条件不可嵌套，但可迭加。构成“逻辑与”关系。

break参数可以使condition构成其他关系。

- on-false。在第一次匹配失败时停止。
- on-true。在第一次匹配成功时停止。
- always。不管是否匹配，都停止。
- never。不管是否匹配，都继续。

#### 动作与反动作

除使用condition的break机制来完成复杂的条件以外，你还可以使用“反动作”来达到类似的目的。

#### 工作机制深入剖析

new->init->routing<->execute->hangup->reporting->destory

ROUNTING和EXECUTE是属于两个不同的阶段，只有ROUTING完毕后才会进行EXECUTE阶段的操作。

#### 内联执行

在Hunting阶段，如果发现带有inline的Action，会直接执行它，而不用等到EXECUT阶段。

```xml
<action inline="true" application="set" data="greeting=no-greeting.wav" />
```

inline会打乱执行顺序，所以使用不当可能会产生非预期的结果。

#### 实例解析

1. Local_Extension

   ```xml
   <extension name="Local_Extension">
       <condition field="destination_number" expression="^(10[01][0-9])$">
       <!-- many actions，此处省略 -->
       </condition>
   </extension>
   ```

   1000呼叫1001时，匹配的结果会放入变量1中，1中，1=1001。

   省略的“many actions”里面的内容：

   ```xml
   <action application="set" data="dialed_extension=$1"/>
   <action application="export" data="dialed_extension=$1"/>
   ```

   set是将变量设置在当前Channel上，及a-leg。

   export是将变量设置在b-leg上，还设置了一个特殊的值。

   上面第二行相当于：

   ```xml
   <action application="set" data="dialed_extension=$1"/>
   <action application="set" data="export_vars=dialed_extension"/>
   ```

   接着：

   ```xml
   <action application="bind_meta_app" data="1 b s execute_extension::dx XML features"/>
   <action application="bind_meta_app" data="2 b s record_session::$${recordings_dir}/${caller_id_number}.${strftime{%Y-%m-%d-%H-%M-%S}}.wav"/>
   <action application="bind_meta_app" data="3 b s execute_extension::cf XML features"/>
   <action application="bind_meta_app" data="4 b s execute_extension::att_xfer XML features"/>
   ```

   bind_meta_app的作用是在该Channel上绑定DTMF（Dual Tone Multi Frequency（双音多频））。上面分别绑定了1、2、3、4四个按钮，都绑定在了b-leg上。

   接着设置回铃音：

   ```xml
   <action application="set" data="ringback=${us-ring}"/>
   ```

   如果发生呼叫转移，听到回铃音：

   ```xml
   <action application="set" data="transfer_ringback=$${hold_music}"/>
   ```

   设置呼叫超时变量：

   ```xml
   <action application="set" data="call_timeout=30"/>
   ```

   ```xml
   <action application="set" data="hangup_after_bridge=true" />
   <action application="set" data="continue_on_fail=true" />
   ```

   ```xml
   <action application="hash" data="insert/${domain_name}-call_return/${dialed_extension}/${caller_id_number}"/>
   <action application="hash" data="insert/${domain_name}-last_dial_ext/${dialed_extension}/${uuid}"/>
   <action application="hash" data="insert/${domain_name}-last_dial_ext/${called_party_callgroup}/${uuid}"/>
   <action application="hash" data="insert/${domain_name}-last_dial_ext/global/${uuid}"/>
   ```

   最后一句：向domainname−lastdialext这个hash表中插入一个global键，值是domainname−lastdialext这个hash表中插入一个global键，值是{uuid}。

   set是将变量设置在Channel上，以通道变量形式存在，而hash保存到内存的哈希表数据结构中。

   设置通道变量：

   ```xml
   <action application="set" data="called_party_callgroup=${user_data(${dialed_extension}@${domain_name} var callgroup)}"/>
   ```

   哈希表中插入数据：

   ```xml
   <action application="hash" data="insert/${domain_name}-last_dial/${called_party_callgroup}/${uuid}"/>
   ```

   终于到了一个干实事的地方：

   ```xml
   <action application="bridge" data="{sip_invite_domain=$${domain}}user/${dialed_extension}@${domain_name}"/>
   ```

   呼叫字符串翻译出来就是：

   ```xml
   {sip_invite_domain=192.168.7.2}user/1001@192.168.2
   ```

   “{}”里是设置通道变量。等价于：

   ```xml
   <action application="export" value="nolocal:sip_invite_domain=192.168.7.2"/>
   <action application="bridge" value="user/1001@192.168.7.2"/>
   ```

   路由完成，接下来可能有几种情况：

   - 被叫应答
   - 被叫忙
   - 被叫无应答
   - 被叫无应答
   - 其他情况…

   bridge一直阻塞，1000挂机，Dialplan没有必要执行了，产生计费信息，并销毁a-leg。

   1001挂机，a-leg依然存在。

   通过给continue_on_fail不同的值，决定在什么情况下继续。

   ```xml
   <action application="set" data="continue_on_fail=USER_BUSY,NO_ANSWER"/>
   ```

   ```xml
   <action application="answer"/>
   ```

   ```xml
   <action application="sleep" data="1000"/>
   <action application="voicemail" data="default ${domain_name} ${dialed_extension}"/>
   ```

   暂停1秒，然后转到1001的语音信箱。

2. 回声和延迟回声

   ```xml
   <extension name="echo">
       <condition field="destination_number" expression="^9196$">
           <action application="answer"/>
           <action application="echo"/>
       </condition>
   </extension>
   ```

   ```xml
   <extension name="delay_echo">
       <condition field="destination_number" expression="^9196$">
           <action application="answer"/>
           <action application="delay_echo" data="5000"/>
       </condition>
   </extension>
   ```

3. 会议

   ```xml
   <extension name="nb_conferences">
       <condition field="destination_number" expression="^(30\d{2})$">
           <action application="answer" data=""/>
           <action application="conference" data="$1-${domain_name}@default"/>
       </condition>
   </extension>
   ```

   30开头的4位数字呼叫，会进入电话会议。

4. 将通话的双发转入会议

   ```xml
   <action application="bind_meta_app" data="3 b s execute_extension::cf XML features"/>
   ```

   1000呼叫1001,1001摘机与1000通话。1001通过按“*3”这个DTMF按键触发execute_extension动作。

   ```xml
   <extension name="cf">
       <condition field="destination_number" expression="^cf$">
           <action application="answer"/>
           <action application="transfer" data="-both 30${dialed_extension:2} XML default"/>
       </condition>
   </extension>
   ```

   transfer一行等价于：

   ```xml
   <action application="transfer" data="-both 3001 XML default"/>
   ```

   -both表示将两条腿分别转到3001这个extension上。

###  inline Dialplan

inline Dialplan称为内联拨号计划。

语法格式：

```xml
app1:arg1,app2:arg2,app3:arg3
```

```xml
originate user/1000 echo inline
originate user/1000 answer,echo inline
```

### 其他Dialplan

查看系统支持多少Dialplan

```xml
show dialplan
```

### 常用的Dialplan App

FreeSWITCH中有超过140个App，常用的有：

1. **set**

   设置一个通道变量。

2. **echo**

   回音

3. **info**

   日志打印全部通道变量。

4. **answer**

   用于应答一路呼叫。

5. **bridge**

   负责桥接另一条腿。

6. **playback**

   playback用于给Channel放音。

7. **sleep**

   设置可以等待/暂停的一段时间。

8. **ring_ready**

   在SIP中给对方回180消息，通知对方可以振铃了。

9. **pre_answer**

   在SIP中给对方回复183消息，后续的playbakck之类的动作作为早期媒体发送给对方。

10. **read**

    用于实现播放声音并且等待接收DTMF按键。

11. **play_and_get_digits**

    与read类似，更高级。

### 在Dialplan中使用API命令

API调用一般是通过set来执行的：

```xml
<action application="set" data="api_result=${status()}"/>
<action application="set" data="api_result=${version()}"/>
<action application="set" data="api_result=${strftime()}"/>
<action application="set" data="api_result=${expr(1+1)}"/>
```

### 深入理解通道变量以及相关操作

给变量赋值：

```xml
<action application="set" data="my_var=my_value"/>
```

export可以对a-leg和b-leg同时赋值（即使此时b-leg不存在）:

```xml
<action application="export" data="my_var=my_value"/>
```

export可以通过nolcal参数将变量限制仅复制到b-leg上：

```xml
<action application="export" data="nolocal:my_var=my_value"/>
```

a-leg上的一些值复制到b-leg上：

```xml
<action application="export" data="var1=$var1"/>
<action application="export" data="var2=$var2"/>
<action application="export" data="var3=$var3"/>
```

等价于：

```xml
<action application="set" data="export_vars=var1,var2,var3"/>
```

取消Variable定义只需对它赋一个特殊值–”*undef*“或使用unset App

```xml
<action application="set" data="var1=_undef_"/>
<action application="unset" data="var1"/>
```

截取Variable值

语法：${var:位置:长度}
