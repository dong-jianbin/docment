---
title: devops
date: 2022-05-07 14:52:12
permalink: /pages/8ffda2/
categories:
  - 项目
  - devops
tags:
  - 
---

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220503163512.png)

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220430160445.png)

### linux系统设置

> mysql远程连接需要关闭防火墙
>
> gitlab需要关闭selinux

#### linux 更新

```shell
yum update -y
```



#### 关闭selinux

```
vi /etc/sysconfig/selinux   SELINUX=disabled
```

#### 关闭防火墙

```shell
systemctl stop firewalld
systemctl disable firewalld
systemctl status firewalld
```

### 容器-docker

> 有网络安装

#### 安装

```shell
 yum install docker
```

#### 启动

```shell
service docker start
chkconfig docker on
```

#### 升级

> Habor 需要17版本以上的docker

```shell
rpm -qa | grep docker  #列出包含docker字段的软件的信息
# docker-1.13.1-161.git64e9980.el7_8.x86_64
# docker-common-1.13.1-161.git64e9980.el7_8.x86_64
# docker-client-1.13.1-161.git64e9980.el7_8.x86_64
yum remove docker-*  #移除上面显示的软件包

curl -fsSL https://get.docker.com/ | sh #使用curl 安装docker最新版本

systemctl restart docker  #重启docker
systemctl enable docker   #设置开机启动
```



### 容器组-docker-compose

#### 下载安装

```shell
sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
```

#### 添加可执行权限

```
sudo chmod +x /usr/local/bin/docker-compose
```

#### 测试安装结果

```
docker-compose --version
```

### 代码管理-gitlab

#### 编写docker-compose.yml文件

```shell
cd /root/soft/dockerfile/gitlab
touch docker-compose.yml
```

```yaml
version: "3"
services:
  gitlab:
    image: docker.io/gitlab/gitlab-ee:latest
    container_name: gitlab
    restart: always
    hostname: '192.168.210.10'
    environment:
      GITLAB_OMNIBUS_CONFIG: |
        external_url "http://192.168.210.10:8929"
        gitlab_rails['gitlab_shell_ssh_port'] = 2222
        gitlab_rails['gitlab_email_enabled'] = true
        gitlab_rails['gitlab_email_from'] = 'xxx@xxxxx.com'
        gitlab_rails['gitlab_email_display_name'] = 'xxx'
        gitlab_rails['gitlab_email_reply_to'] = 'xxxx@xxxxx.com'
        gitlab_rails['smtp_enable'] = true
        gitlab_rails['smtp_address'] = "smtp.mxhichina.com"
        gitlab_rails['smtp_port'] = 465
        gitlab_rails['smtp_user_name'] = "xxx@xxxx.com"
        gitlab_rails['smtp_password'] = "xxxxx"
        gitlab_rails['smtp_domain'] = "smtp.mxhichina.com"
        gitlab_rails['smtp_authentication'] = "login"
        gitlab_rails['smtp_enable_starttls_auto'] = true
        gitlab_rails['smtp_openssl_verify_mode'] = 'peer'
        gitlab_rails['smtp_tls'] = true
    ports:
      - '8929:8929'
      - '2222:22'
      - '8443:443'
    volumes:
      - '/root/soft/gitlab/config:/etc/gitlab'
      - '/root/soft/gitlab/logs:/var/log/gitlab'
      - '/root/soft/gitlab/data:/var/opt/gitlab'
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "10"
```

> 端口映射，不能写80映射。不知道什么原因？？？

#### 启动容器

```shell
docker-compose up -d
```

#### 验证

```shell
#日志查看，启动要很久
docker-compose logs -f

#web url
http://192.168.210.10:8929/
```

#### 登录

```shell
#root初始化密码
cd /root/soft/gitlab/config
vi initial_root_password

#改成新密码
root/djb%741280
```

### 构建-maven

> 本地（非docker）安装,为jenkins使用,环境可不配置。

#### 下载

```shell
wget https://dlcdn.apache.org/maven/maven-3/3.8.5/binaries/apache-maven-3.8.5-bin.tar.gz
```

#### 解压

```shell
tar -xvf apache-maven-3.8.5-bin.tar.gz
mv apache-maven-3.8.5 maven
```

#### 环境配置

```shell
#vi .bash_profile
MAVEN_HOME=/root/soft/maven
export MAVEN_HOME
export PATH=${PATH}:${MAVEN_HOME}/bin

#生效
source .bash_profile 
```

#### 测试

```shell
mvn -v
```

#### 私服仓库

```xml
cd /root/soft/maven/conf
vi settings.xml
			<mirror>
        <id>nexus-aliyun</id>
        <mirrorOf>central</mirrorOf>
        <name>Nexus aliyun</name>
        <url>http://maven.aliyun.com/nexus/content/groups/public</url>
      </mirror>
```

#### JDK 版本

Maven默认 JDK 版本是 1.5,改成 JDK 1.8 版本

```xml
cd /root/soft/maven/conf
vi settings.xml

	<profile>
	  <id>jdk-1.8</id>
	  <activation>
			<activeByDefault>true</activeByDefault>
			<jdk>1.8</jdk>
	  </activation>
	  <properties>
			<maven.compiler.source>1.8</maven.compiler.source>
			<maven.compiler.target>1.8</maven.compiler.target>
			<maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>
	  </properties>
	</profile>

  <activeProfiles>
    <activeProfile>jdk-1.8</activeProfile>
  </activeProfiles>

```

### java开发包-jdk

> 本地（非docker）安装,为jenkins使用,环境可不配置。

#### 下载

官网下载 https://www.oracle.com/java/technologies/downloads/

#### 解压

```shell
tar -xvf jdk-8u333-linux-x64.tar.gz
mv jdk1.8.0_333 jdk
```

#### 环境设置

```shell
#vi .bash_profile
export JAVA_HOME=/root/soft/jdk
CLASSPATH=.:${JAVA_HOME}/jre/lib/rt.jar:${JAVA_HOME}/lib/dt.jar:${JAVA_HOME}/lib/tools.jar

export PATH=$PATH:${JAVA_HOME}/bin

#生效
source .bash_profile
```

### 持续集成工具-jenkins

#### 安装镜像

```shell
docker pull jenkins/jenkins:2.332.3-lts
```

#### 编写docker-compose.yml文件

```yaml
cd /root/soft/dockerfile/jenkins
touch docker-compose.yml

version: '3'   # 定义版本，不指定默认为版本 1，新版本功能更多
services:      # 容器
  jenkins:
    image: 'jenkins/jenkins:2.332.3-lts'    # 镜像
    container_name: jenkins         # 容器名称
    privileged: true # 解决权限问题
    restart: always # 同 --restart 参数
    ports:  # 端口映射，同 -p 参数，本地端口:容器端口
      - '8099:8080'
      - '50000:50000'
    volumes: # 数据卷,本地文件夹:容器文件夹
      - '/root/soft/jenkins:/var/jenkins_home'
```

#### 启动容器

> 映射目录的写权限
>
> Can not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions?
>
> ```shell
> cd /root/soft/
> chmod 777 -R jenkins/
> ```

```shell
docker-compose up -d
```

#### 验证

```shell
#日志查看
docker-compose logs -f

#url
http://192.168.210.10:8099/
```

#### 登录

```shell
#root初始化密码，修改成可用密码
cd /root/soft/jenkins/secrets
cat initialAdminPassword
```

#### 选择插件来安装

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220429135725.png)

按照默认选择，确定安装

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220429135942.png)

创建用户 dongjb/dongjb

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220429144249.png)

选择安装组件

Manage jenkins -> manage plugins

Git Parameter

Publish Over SSH

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220429145145.png)

#### 移动jdk，maven到jenkins的映射目录

```shell
cd /root/soft/jenkins
mv /root/soft/jdk/ ./
mv /root/soft/maven/ ./
```

#### 全局配置

1. jdk配置

   配置jdk路径，用于jenkins调用

   ```shell
   jdk8
   /var/jenkins_home/jdk
   ```

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220429154945.png)

2. maven配置

   配置maven的路径，用于jenkins调用

   ```
   maven
   /var/jenkins_home/maven
   ```

   

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220501173306.png)

#### 系统配置

1. Publish over SSH

   配置ssh服务，用于文件传输，本例传输到本地的目录

   ```
   test
   192.168.210.10
   root
   /root/soft/ssh
   dongjb
   ```

   

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220429160104.png)

### CI实例

#### IDEA项目

1. 新建项目

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220429185357.png)

2. 启动项目

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220429185705.png)

3. 测试结果

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220429185836.png)

#### gitlab代码托管

1. 新建项目

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220429190117.png)

2. 不要选择readme

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220501174748.png)

3. 空的项目

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220501174903.png)

#### 项目版本控制

```shell
cd /Users/mac/IdeaProjects/lean/devops

git config --global user.name "Administrator"
git config --global user.email "admin@example.com"

cd /Users/mac/IdeaProjects/lean/devops
git init --initial-branch=main
git remote add origin http://192.168.210.10:8929/gitlab-instance-571ecef5/devops.git
git add .
git commit -m "Initial commit"
git push -u origin main

#root/djb%741280
```

#### jenkins任务

##### 新建任务

```
testdevops
```

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220429210906.png)

##### 源码配置

1. 配置填写，代码库url，2.身份校验，3.分支，确定提交	

   ```
   http://192.168.210.10:8929/gitlab-instance-571ecef5/devops.git
   root/djb%741280
   */main
   ```

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220429231154.png)

2. 根据gitlab服务器配置生成凭证，root，djb%741280

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220429231451.png)

3. 执行任务并查看结果

   ```shell
   #jenkins映射目录中查看代码
   cd /root/soft/jenkins/workspace
   #是否存在项目代码
   ```

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220429231918.png)

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220429232047.png)

##### 构建配置

1. 填写maven配置，填写maven版本，maven命令：clean package -DskipTest

   ```
   #调用顶层maven目标
   maven
   clean package -DskipTest
   
   ```

   ##### ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220430082748.png)

2. 执行任务并查看结果

   ```
   #jenkins映射目录中查看代码
   cd /root/soft/jenkins/workspace
   #是否存在target目录中的jar包
   Ssh配置
   ```


##### 构建后操作SSH配置

1. 填写配置，选择send build artifacts over SSH,然后选择ssh服务(全局配置): test，填写 **Source files**：target/*.jar

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220430091204.png)

2. 执行任务并查看结果

   ```shell
   #查看ssh上传目录(系统配置中设置)是否有上传文件
   cd /root/soft/ssh
   target/devops-0.0.1-SNAPSHOT.jar
   ```


##### Docker配置

1. 项目代码中增加Dockerfile,docker-compose.yml

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220430095940.png)

2. Docker配置

   **Source files**:`docker/*`

   **Exec command**:

   ```
   cd /root/soft/jenkins/workspace/testdevops/docker
   mv ../target/*.jar ./
   docker-compose down
   docker-compose up -d --build
   docker image prune -f
   ```

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220501193807.png)

   

3. 执行任务并查看结果

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220430102829.png)

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220430102919.png)

##### 参数构建配置

1. 参数配置，任务配置->参数化构建过程->git参数->填写`名称`，`描述`。参数类型选择`标签`

   ```
   tag
   标签
   origin/main
   ```

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220430123537.png)

   构建`maven构建`之前增加构建步骤`执行shell`，shell命令内容：`git checkout $tag`

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220506144018.png)

2. gitlab标签创建

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220430125001.png)

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220430125139.png)

   修改代码上传后，在gitlab再新建一个tag

3. 执行任务并查看结果

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220430130708.png)

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220430131617.png)

   换个tag重新构建，再查看结果，最终实现参数化动态构建

### Sonarqube代码质量

#### 安装

1. 镜像拉取

   ```shell
   #要数据库支持postgres
   docker pull postgres
   docker pull sonarqube:8.9.8-community
   ```

2. doker-compose.yml

   ```shell
   cd /root/soft/dockerfile/sonarqube
   touch docker-compose.yml
   ```

   ```yaml
   version: '3.1'
   services:
     db:
       image: postgres
       container_name: db
       restart: always
       ports:
         - 5432:5432
       networks:
         - sonarnet
       environment:
         POSTGRES_USER: sonar
         POSTGRES_PASSWORD: sonar
     sonarqube:
       image: sonarqube:8.9.8-community
       container_name: sonarqube
       restart: always
       depends_on:
         - db
       volumes:
         - /root/soft/sonarqube/extensions:/opt/sonarqube/extensions
         - /root/soft/sonarqube/logs:/opt/sonarqube/logs
         - /root/soft/sonarqube/data:/opt/sonarqube/data
         - /root/soft/sonarqube/conf:/opt/sonarqube/conf
       ports:
         - 9000:9000
       networks:
         - sonarnet
       environment:
         SONAR_JDBC_URL: jdbc:postgresql://db:5432/sonar
         SONAR_JDBC_USERNAME: sonar
         SONAR_JDBC_PASSWORD: sonar
   networks:
     sonarnet:
       driver: bridge
   ```

3. 启动验证

   ```shell
   #修改系统参数`虚拟内存`
   #bootstrap check failure [1] of [1]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]
   
   vi /etc/sysctl.conf
   vm.max_map_count=462144
   
   sysctl -p
   ```

   启动

   ```
   docker-compose up -d
   ```

   验证

   ```shell
   http://192.168.210.10:9000/
   #默认
   admin/admin
   #修改
   admin/dongjb
   ```

4. 中文环境插件

   Administration-> Marketplace， 安装后要重启系统

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220430203103.png)

#### Maven 方式运行

1. Maven setting.xml文件中添加sonarqube设置

   ```xml
   			<profile>
               <id>sonar</id>
               <activation>
                   <activeByDefault>true</activeByDefault>
               </activation>
               <properties>
                   <sonar.login>admin</sonar.login>
                   <sonar.password>dongjb</sonar.password>
                   <sonar.host.url>http://192.168.210.10:9000</sonar.host.url>
               </properties>
           </profile>
   
   ```

2. 运行

   ```shell
   #项目目录下
   mvn sonar:sonar
   ```

3. 日志结果

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220430210014.png)

4. 控制台

   `http://192.168.210.10:9000/`

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220430210209.png)

#### sonar-scanner

1. 安装

   ```shell
   wget https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-4.7.0.2747-linux.zip
   yum install unzip
   unzip sonar-scanner-cli-4.7.0.2747-linux.zip
   
   #转存到jenkins的home下
   cd /root/soft/jenkins
   mv /root/sonar-scanner-4.7.0.2747-linux/ sonar-scanner
   
   ```

2. 修改配置

   ```shell
   cd /root/soft/jenkins/sonar-scanner/conf
   vi sonar-scanner.properties
   ip要修改成主机ip，编码
   ```

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220430221932.png)

3. 获取token

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220430223127.png)

4. 执行

   ```shell
   #进入项目目录
   cd /root/soft/jenkins/workspace/testdevops
   #执行
   /root/soft/jenkins/sonar-scanner/bin/sonar-scanner -Dsonar.sources=. -Dsonar.projectname=linux-test -Dsonar.login=904c58912f3f3e0652529fb58fbb22affe180130 -Dsonar.projectKey=linux-test -Dsonar.java.binaries=./target
   ```

5. 运行结果

   查看日志

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220430230752.png)

   查看控制台

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220501212255.png)

#### sonarqube整合到jenkins

1. jenkins中安装sonarqube插件

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220501102948.png)

   重新启动jenkins`http://192.168.210.10:8080/restart` 

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220501103509.png)

2. jenkins中配置sonar

   系统管理->系统配置 配置SonarQube servers， 输入服务名称：sonarqube，url：http://192.168.210.10:9000/

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220501104305.png)

   凭证，类型采用secret text方式。secret是在sonarqube中生成的token

   > 当sonarqube重建的话，这个令牌会失效。需要重新获取
   >
   > 还是改成，用户名/密码方式好点

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220501104733.png)

3. 系统管理->全局配置 配置SonarQube Scanner，输入名称：sonar-scanner,输入home：/var/jenkins_home/sonar-scanner

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220501110019.png)

4. jenkins任务，修改配置,`增加构建步骤`->execute sonarqube scanner

   如果之前有手工运行scanner ，需删除项目下 .scannerwork目录

   ```
   选择jdk：jdk8
   #分析参数：
   sonar.projectname=${JOB_NAME
   sonar.projectKey=${JOB_NAME}
   sonar.sources=./
   sonar.java.binaries=target
   ```

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220501110841.png)

5. 运行jenkins任务，并查看sonar结果

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220501111819.png)

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220501222941.png)

### habor镜像仓库

#### 安装

##### 下载

```
wget https://github.com/goharbor/harbor/releases/download/v2.5.0/harbor-offline-installer-v2.5.0.tgz

tar -zxvf harbor-offline-installer-v2.5.0.tgz
mv harbor /root/soft/dockerfile/
```

##### 配置

```shell
#由模板生成配置文件
cd /root/soft/dockerfile/harbor
cp harbor.yml.tmpl harbor.yml

#vi harbor.yml
修改hostname: 192.168.210.10
端口为：80
注释掉https相关配置
harbor_admin_password: Harbor12345
```

##### 运行

脚本，安装镜像，运行容器。需要docker环境

`./install.sh`

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220502100340.png)

##### 验证

http://192.168.210.10:80

admin/Harbor12345

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220502101407.png)

##### 项目启停

```shell
#配置，安装后生成配置文件
vi /root/soft/dockerfile/harbor/docker-compose.yml

#运行
docker-compose up -d
#删除
docker-compose down
#重启
docker-compose restart
```

#### 基本操作

##### 新建项目

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220502124426.png)

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220502124523.png)

##### docker配置

设置私有仓库地址

```json
vi /etc/docker/daemon.json
{
 "insecure-registries": ["192.168.210.10:80"]
}

#修改配置后要重启docker服务
systemctl restart docker  #重启docker
```

##### 修改镜像名称

> 需要推送到仓库的镜像标准格式，通过tag方式重新给镜像取别名
>
> habor地址/仓库名称/镜像名：版本

```shell
docker tag c883a733c469 192.168.210.10:80/repo/mytest:v2.0.0
```

##### 推送镜像

```shell
#先登录
docker login -u admin -p Harbor12345 192.168.210.10:80
#推
docker push 192.168.210.10:80/repo/mytest:v2.0.0
```

推送成功

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220502141649.png)

##### 拉取镜像

```shell
#先登录,public仓库不需登录
docker login -u admin -p Harbor12345 192.168.210.10:80
#拉
docker pull 192.168.210.10:80/repo/mytest:v2.0.0
```

#### jenkins内运行docker

1. jenkins容器内安装daocker，比较困难，依赖的比较多。
2. 使用jenkins宿主机上的docker

为了实现方案2的目标需要如下修改

##### docker核心文件docker.sock

1. 修改权限所属组

   ```shell
   cd /var/run
   #有root docker 改成 root root
   chown root:root docker.sock
   ```

2. 修改文件的权限,让其他用户也有读和写的权限

   ```
   chmod o+rw docker.sock
   ```

##### 修改docker-compose.yml

```yaml
cd /root/soft/dockerfile/jenkins
vi docker-compose.yml
#更改数据卷

version: '3'   # 定义版本，不指定默认为版本 1，新版本功能更多
services:      # 容器
  jenkins:
    image: 'docker.io/jenkins/jenkins:2.332.3-lts'    # 镜像
    container_name: jenkins         # 容器名称
    privileged: true # 解决权限问题
    restart: always # 同 --restart 参数
    ports:  # 端口映射，同 -p 参数，本地端口:容器端口
      - '8099:8080'
      - '50000:50000'
    volumes: # 数据卷,本地文件夹:容器文件夹
      - '/root/soft/jenkins:/var/jenkins_home'
      - '/var/run/docker.sock:/var/run/docker.sock'
      - '/usr/bin/docker:/usr/bin/docker'
      - '/etc/docker/daemon.json:/etc/docker/daemon.json'
```

重新构建容器: `docker-compose up -d`

##### 验证容器内使用docker

```shell
docker exec -it 4a034ac79220 bash
docker -v
```

#### habor整合到jenkins

##### 修改任务配置

1. 删除原有的`构建后操作`

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220502171029.png)

2. 增加构建步骤，在代码检查后，选择`执行shell`。用于制作镜像

   命令内容

   ```shell
   mv target/*.jar docker/
   docker build -t mytest:$tag docker/
   docker login -u admin -p Harbor12345 192.168.210.10:80
   docker tag mytest:$tag 192.168.210.10:80/repo/mytest:$tag
   docker push 192.168.210.10:80/repo/mytest:$tag
   ```

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220502173824.png)

##### 构建验证

1. 修改代码上传，新建tag v4.0.0。

   代码中的Dockerfile是需要的，docker-compose.yml不需要了。

2. Harbor中查看镜像

   ![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220502174043.png)

#### 通知构建

##### 部署脚本

1. 告知服务器拉取哪个镜像
2. 判断当前服务器是否运行容器，需要删除
3. 判断当前服务器是否存在此镜像，需要删除
4. 当前服务器拉取harbor上的镜像
5. 把拉取下的镜像运行成容器

```shell
cd /root/soft/dockerfile/shell
vi deploy.sh
```

```shell
harbor_addr=$1
harbor_repo=$2
project=$3
version=$4
port=$5

imageName=$harbor_addr/$harbor_repo/$project:$version
echo $imageName

containerId=`docker ps -a | grep ${project} | awk '{print $1}'`
echo $containerId

if [ "$containerId" != "" ] ; then
	docker stop $containerId
	docker rm $containerId
fi

tag=`docker images | grep ${project} | awk '{print $2}'`
echo $tag

if [[ "$tag" =~ "$version" ]] ; then
	docker rmi -f $imageName
fi

docker login -u admin -p Harbor12345 $harbor_addr
docker pull $imageName

docker run -d -p $port:$port --name $project $imageName

echo "SUCCESS"
```

```
cd /root/soft/dockerfile/shell
#赋权
chmod a+x deploy.sh
#运行
./deploy.sh 192.168.210.10:80 repo mytest v4.0.0 8081
#拷贝到/usr/bin
cp deploy.sh /usr/bin
```

##### Jenkins 调用脚本

```
deploy.sh 192.168.210.10:80 repo mytest $tag $port
```

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220502224313.png)

### 流水线

#### 新建项目

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220503085152.png)

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220503085338.png)

#### 项目配置

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220503085556.png)

##### 流水线脚本编写

```
//所有脚本命令都放到pipeline中
pipeline {
		//指定任务在哪个jenkins集群节点中执行
    agent any
    
    //声明全局变量，方便后面使用
    environment {
    	key = 'value'
    }

    stages {
        stage('拉取git仓库代码') {
            steps {
                echo '拉取git仓库代码 - SUCCESS'
            }
        }
        stage('通过MAVEN构建项目') {
            steps {
                echo '通过MAVEN构建项目 - SUCCESS'
            }
        }
        stage('通过SONARQUBE做代码质量检测') {
            steps {
                echo '通过SONARQUBE做代码质量检测 - SUCCESS'
            }
        }
        stage('通过docker制作自定义镜像') {
            steps {
                echo '通过docker制作自定义镜像 - SUCCESS'
            }
        }
        stage('将自定义镜像推送到harbor仓库') {
            steps {
                echo '将自定义镜像推送到harbor仓库 - SUCCESS'
            }
        }
        stage('通过publish over ssh 通知目标服务器') {
            steps {
                echo '通过publish over ssh 通知目标服务器 - SUCCESS'
            }
        }
    }
}

```

项目配置中，修改脚本，然后执行。

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220503094845.png)

##### 流水线脚本git托管

1. 在项目中新建文件，名称必须为：Jenkinsfile，提交代码

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220503101559.png)

2. 修改任务中，流水线配置

```
pipeline script from scm
git
http://192.168.210.10:8929/gitlab-instance-571ecef5/devops.git
root
djb%741280
*/main
Jenkinsfile
```

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220503102700.png)

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220503102828.png)

##### 拉取git仓库代码

1. 填写git相关配置，另外在`参数化构建过程` 增加tag参数

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220503104149.png)

2. 点击`生成流水线脚本`

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220503104257.png)

3. 把生成的脚本放到jenkinsfile文件中

> */main 改成 ${tag}

```json
        stage('拉取git仓库代码') {
            steps {
                checkout([$class: 'GitSCM', branches: [[name: '${tag}']], extensions: [], userRemoteConfigs: [[credentialsId: 'e77dae76-970f-4849-ae62-2b4b0fa74ccf', url: 'http://192.168.210.10:8929/gitlab-instance-647f3442/devops.git']]])
            }
        }
```

##### 通过MAVEN构建项目

1. 填写配置

```
/var/jenkins_home/maven/bin/mvn clean package -DskipTests
```

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220503113648.png)

1. 把生成的脚本放到jenkinsfile文件中

```json
        stage('通过MAVEN构建项目') {
            steps {
                sh '/var/jenkins_home/maven/bin/mvn clean package -DskipTests'
            }
        }
```

##### 通过SONARQUBE做代码质量检测

1. 填写配置

```shell
/var/jenkins_home/sonar-scanner/bin/sonar-scanner  -Dsonar.sources=./ -Dsonar.projectname=${JOB_NAME} -Dsonar.login= c8a95acfd8faf9d0217539dab84fce09c1c50df3 -Dsonar.projectKey=${JOB_NAME}  -Dsonar.java.binaries=./target
```

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220503115159.png)

2. 把生成的脚本放到jenkinsfile文件中

```json
        stage('通过SONARQUBE做代码质量检测') {
            steps {
                sh '/var/jenkins_home/sonar-scanner/bin/sonar-scanner  -Dsonar.sources=./ -Dsonar.projectname=${JOB_NAME} -Dsonar.login=c8a95acfd8faf9d0217539dab84fce09c1c50df3 -Dsonar.projectKey=${JOB_NAME}  -Dsonar.java.binaries=./target'
            }
        }
```

##### 通过docker制作自定义镜像

1. 2填写配置

```shell
mv ./target/*.jar ./docker/
docker build -t ${JOB_NAME}:${tag} ./docker/
```

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220503120832.png)

把生成的脚本放到jenkinsfile文件中

```json
        stage('通过docker制作自定义镜像') {
            steps {
                sh '''mv ./target/*.jar ./docker/
                docker build -t ${JOB_NAME}:${tag} ./docker/'''
            }
        }
```

##### 将自定义镜像推送到harbor仓库

填写配置

```shell
docker login -u admin -p Harbor12345 192.168.210.10:80
docker tag ${JOB_NAME}:$tag 192.168.210.10:80/repo/${JOB_NAME}:$tag
docker push 192.168.210.10:80/repo/${JOB_NAME}:$tag
```

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220503122002.png)

2. 把生成的脚本放到jenkinsfile文件中

```json
    environment {
    	harborUsername = 'admin'
    	haborPassword = 'Harbor12345'
    	haborAddress = '192.168.210.10:80'
    	haborRepo = 'repo'
    }

        stage('将自定义镜像推送到harbor仓库') {
            steps {
                sh '''docker login -u ${harborUsername} -p ${haborPassword} ${haborAddress}
                docker tag ${JOB_NAME}:$tag ${haborAddress}/${haborRepo}/${JOB_NAME}:$tag
                docker push ${haborAddress}/${haborRepo}/${JOB_NAME}:$tag'''
            }
        }
```

##### 通过publish over ssh 通知目标服务器

1. 填写配置

```shell
deploy.sh $haborAddress $haborRepo $JOB_NAME $tag $port
```

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220503135343.png)

2. 设置port参数

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220503140210.png)

3. 把生成的脚本放到jenkinsfile文件中

> "deploy.sh $haborAddress $haborRepo $JOB_NAME $tag $port"
>
> 一定要双引号，不能用单引号

````
        stage('通过publish over ssh 通知目标服务器') {
            steps {
                sshPublisher(publishers: [sshPublisherDesc(configName: 'test', transfers: [sshTransfer(cleanRemote: false, excludes: '', execCommand: "deploy.sh $haborAddress $haborRepo $JOB_NAME $tag $port", execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: '[, ]+', remoteDirectory: '', remoteDirectorySDF: false, removePrefix: '', sourceFiles: '')], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])
            }
        }
````

##### 构建后钉钉通知消息

1. 钉钉应用

​	钉钉pc版中，创建群，并在群中设置机器人。并输出如下hook

```shell
https://oapi.dingtalk.com/robot/send?access_token=18760ab227d9d7948cf949a7bbe58cd9faf9cf6818843d89010126f44027964b
```

2. jenkins中下载插件- DingTalk
3. Jenkins系统管理->系统配置，配置钉钉

```
构建中断时 构建失败时 构建成功时 构建不稳定时
jinkins-dingding
jinkins-dingding
https://oapi.dingtalk.com/robot/send?access_token=18760ab227d9d7948cf949a7bbe58cd9faf9cf6818843d89010126f44027964b
部署
```

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220503162755.png)

3. 把生成的脚本放到jenkinsfile文件中

```
    post {
        success {
            dingtalk(
                robot: 'jinkins-dingding',
                type: 'MARKDOWN',
                title: "success: ${JOB_NAME} ",
                text: ["- 成功构建：${JOB_NAME}! \n - 版本：${tag} \n - 持续时间： ${currentBuild.durationString} "]
            )
        }
        failure {
            dingtalk(
                 robot: 'jinkins-dingding',
                 type: 'MARKDOWN',
                 title: "failure: ${JOB_NAME} ",
                 text: ["- 失败构建：${JOB_NAME}! \n - 版本：${tag} \n - 持续时间： ${currentBuild.durationString} "]
            )
        }
    }
```

4. 验证消息

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220503162537.png)

### Kubernetes

官网： https://kubernetes.io/zh/

#### Kuboard安装Kubernetes

官网： https://kuboard.cn/

##### 选择版本

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220504191425.png)

##### 环境准备

- 至少2台 **2核4G** 的服务器
- **Cent OS 7.6 / 7.7 / 7.8**

##### 检查 centos / hostname

```sh
# 在 master 节点和 worker 节点都要执行
cat /etc/redhat-release

# 此处 hostname 的输出将会是该机器在 Kubernetes 集群中的节点名字
# 不能使用 localhost 作为节点的名字
hostname

# 请使用 lscpu 命令，核对 CPU 信息
# Architecture: x86_64    本安装文档不支持 arm 架构
# CPU(s):       2         CPU 内核数量不能低于 2
lscpu

#网络不能太复杂
/etc/sysconfig/network-scripts/ifcfg-ens33
systemctl restart network
```

##### 修改 hostname

如果您需要修改 hostname，可执行如下指令：

```shell
# 修改 hostname
hostnamectl set-hostname k8smaster
hostnamectl set-hostname k8sworker
# 查看修改结果
hostnamectl status
# 设置 hostname 解析
echo "127.0.0.1   $(hostname)" >> /etc/hosts
```

##### 安装docker及kubelet

两台机器都要执行

```sh
export REGISTRY_MIRROR=https://registry.cn-hangzhou.aliyuncs.com
curl -sSL https://kuboard.cn/install-script/v1.19.x/install_kubelet.sh | sh -s 1.19.5
```

##### 初始化master节点

```sh
# 只在 master 节点执行
# 替换 x.x.x.x 为 master 节点实际 IP（请使用内网 IP）
# export 命令只在当前 shell 会话中有效，开启新的 shell 窗口后，如果要继续安装过程，请重新执行此处的 export 命令
export MASTER_IP=192.168.210.20
# 替换 apiserver.demo 为 您想要的 dnsName
export APISERVER_NAME=asiainfo.com
# Kubernetes 容器组所在的网段，该网段安装完成后，由 kubernetes 创建，事先并不存在于您的物理网络中
export POD_SUBNET=10.100.0.1/16
echo "${MASTER_IP}    ${APISERVER_NAME}" >> /etc/hosts
curl -sSL https://kuboard.cn/install-script/v1.19.x/init_master.sh | sh -s 1.19.5
```

##### 检查 master 初始化结果

```sh
# 只在 master 节点执行

# 执行如下命令，等待 3-10 分钟，直到所有的容器组处于 Running 状态
watch kubectl get pod -n kube-system -o wide

# 查看 master 节点初始化结果
kubectl get nodes -o wide
```

##### 初始化 worker节点

 获得 join命令参数,**在 master 节点上执行**

```shell
# 只在 master 节点执行
kubeadm token create --print-join-command
```

可获取kubeadm join 命令及参数，如下所示

```shell
kubeadm join asiainfo.com:6443 --token ihq9xt.8klvozfnwyu3429o     --discovery-token-ca-cert-hash sha256:d79f055719dd2ebc3660ceebae75d20235cf3231e288ec967726c495386ab89a
```

初始化worker,针对所有的 worker 节点执行

```
# 只在 worker 节点执行
# 替换 x.x.x.x 为 master 节点的内网 IP
export MASTER_IP=192.168.210.20
# 替换 apiserver.demo 为初始化 master 节点时所使用的 APISERVER_NAME
export APISERVER_NAME=asiainfo.com
echo "${MASTER_IP}    ${APISERVER_NAME}" >> /etc/hosts

# 替换为 master 节点上 kubeadm token create 命令的输出
kubeadm join asiainfo.com:6443 --token ihq9xt.8klvozfnwyu3429o     --discovery-token-ca-cert-hash sha256:d79f055719dd2ebc3660ceebae75d20235cf3231e288ec967726c495386ab89a
```

##### 检查初始化结果

在 master 节点上执行

```sh
# 只在 master 节点执行
kubectl get nodes -o wide
```

####  Kuboard管理工具

Kubernetes 图形管理工具，在 K8S 中安装 Kuboard v3

```sh
# kubectl apply -f https://addons.kuboard.cn/kuboard/kuboard-v3.yaml
# 您也可以使用下面的指令，唯一的区别是，该指令使用华为云的镜像仓库替代 docker hub 分发 Kuboard 所需要的镜像
# master 上执行
kubectl apply -f https://addons.kuboard.cn/kuboard/kuboard-v3-swr.yaml
```

##### 等待 Kuboard v3 就绪

`watch kubectl get pods -n kuboard`

#####  访问 Kuboard

- 在浏览器中打开链接 `http://192.168.210.20:30080`
- 输入初始用户名和密码，并登录
  - 用户名： `admin`
  - 密码： `Kuboard123`

#### k8s基本操作

##### namespace操作

```
kubectl get ns
kubectl create ns test
kubectl delete ns test
```

```yml
#调用脚本执行命令
#vi namespace-test.yml

apiVersion: v1
kind: Namespace
metadata:
  name: test
	
#调用
kubectl apply -f namespace-test.yml
```

##### pod操作

```yaml
kubectl get pods
kubectl get pods -A
kubectl get pods -n test

kubectl run nginx --image=nginx -n test
kubectl describe pods nginx -n test

kubectl delete pods nginx -n test

kubectl exec -it nginx bash -n test
```

一个pod多个docker的yml编写

```shell
# vi pod-nginx-tomcat.yml

apiVersion: v1
kind: Pod
metadata:
	name:  nginx-tomcat
	namespace: test
spec:
	containers:
	- image: nginx
		name: nginx
	- image: tomcat
	  name: tomcat
	  
#kubectl apply -f pod-nginx-tomcat.yml
```

##### deployment

```
kubectl get deployment -n test
kubectl create deployment deploy-nginx -n test --image=nginx
kubectl delete deployment deploy-nginx
```

```yaml
#脚本方式创建
#vi nginx-deployment.yml
apiVersion: apps/v1
kind: Deployment
metadata:
	namespace: test
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
        
#执行
kubectl apply -f nginx-deployment.yml -n test
```

##### Service操作

```
kubectl expose deployment nginx-deployment --port=8888 --target-port=80 -n test
kubectl get service -n test
kubectl delete service nginx-deployment -n test
#type=NodePort暴露对外端口
kubectl expose deployment nginx-deployment --port=8888 --target-port=80 -n test --type=NodePort

#根据service的ip和端口就可以访问了
curl 10.96.110.154:8888
http://192.168.210.20:31925/
```

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220505110935.png)

通过脚本，pod，deployment，service一同部署

修改deployment的脚本

```yaml
#脚本方式创建
#vi nginx-deployment.yml
apiVersion: apps/v1
kind: Deployment
metadata:
	namespace: test
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
	namespace: test
	name: nginx-deployment
	labels:
		app: nginx-deployment
spec:
	selector:
		app: nginx
	ports:
	- port: 8888
		targetPort: 80
	type: NodePort
#执行
kubectl apply -f nginx-deployment.yml -n test
```

##### Ingress

安装

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220505113803.png)

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220505114021.png)

```yaml
#先删除
kubectl delete -f nginx-deployment.yml

#脚本编写

apiVersion: apps/v1
kind: Deployment
metadata:
  namespace: test
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  namespace: test
  name: nginx-deployment
  labels:
    app: nginx-deployment
spec:
  selector:
    app: nginx
  ports:
  - port: 8888
    targetPort: 80
  type: NodePort
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  namespace: test
  name: nginx-ingress
spec:
  ingressClassName: ingress
  rules:
  - host: asiainfo.nginx.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: nginx-deployment
            port:
              number: 8888
    		
#执行
kubectl apply -f nginx-deployment.yml -n test
```

配置本地机器的域名映射

```shell
#vi /etc/hosts
192.168.210.20 asiainfo.nginx.com
```

域名访问

服务的端口

http://asiainfo.nginx.com:32131/

ingress端口

http://asiainfo.nginx.com:31610/

部署的k8s的yml脚本

#### jenkins部署到k8s

##### k8s部署脚本

idea项目新增yml文件，pipeline.yml

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  namespace: test
  name: pipeline
  labels:
    app: pipeline
spec:
  replicas: 2
  selector:
    matchLabels:
      app: pipeline
  template:
    metadata:
      labels:
        app: pipeline
    spec:
      containers:
        - name: pipeline
          image: 192.168.210.10:80/repo/pipeline:v4.0.0
          imagePullPolicy: Always
          ports:
            - containerPort: 8081
---
apiVersion: v1
kind: Service
metadata:
  namespace: test
  name: pipeline
  labels:
    app: pipeline
spec:
  selector:
    app: pipeline
  ports:
    - port: 8081
      targetPort: 8081
  type: NodePort
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  namespace: test
  name: pipeline
spec:
  ingressClassName: ingress
  rules:
    - host: asiainfo.nginx.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: pipeline
                port:
                  number: 8081

```

kubectl apply -f pipeline.yml 

##### 配置k8s私服信息

1. kuboard中配置harbor服务信息

![image-20220505212420033](/Users/mac/Downloads/Devops.assets/image-20220505212420033.png)

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220505212929.png)

2. docker daemon配置

在两台机器中都要配置

```shell
#vi /etc/docker/daemon.json
{
 "insecure-registries": ["192.168.210.10:80"]
}
#重启docker
systemctl restart docker
```

3. 连接harbor 测试，两台都要联通

```
docker login 192.168.210.10:80 -u admin -p Harbor12345
```

##### Jenkins整合k8s

1. 系统管理->系统配置，配置到k8s的ssh服务

```
k8s
192.168.210.20
root/dongjb
/usr/local/k8s
```



![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220505225840.png)

2. 生成传输pipeline.yml的ssh的脚本

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220505230454.png)

```
sshPublisher(publishers: [sshPublisherDesc(configName: 'k8s', transfers: [sshTransfer(cleanRemote: false, excludes: '', execCommand: '', execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: '[, ]+', remoteDirectory: '', remoteDirectorySDF: false, removePrefix: '', sourceFiles: 'pipeline.yml')], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])
```

修改jenkinsfile

```
        stage('通过publish over ssh 通知目标服务器部署') {
            steps {
                sshPublisher(publishers: [sshPublisherDesc(configName: 'test', transfers: [sshTransfer(cleanRemote: false, excludes: '', execCommand: "deploy.sh $haborAddress $haborRepo $JOB_NAME $tag $port", execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: '[, ]+', remoteDirectory: '', remoteDirectorySDF: false, removePrefix: '', sourceFiles: '')], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])
            }
        }
        
  改成
        stage('通过publish over ssh 传送yml文件到k8smaster上') {
            steps {
sshPublisher(publishers: [sshPublisherDesc(configName: 'k8s', transfers: [sshTransfer(cleanRemote: false, excludes: '', execCommand: '', execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: '[, ]+', remoteDirectory: '', remoteDirectorySDF: false, removePrefix: '', sourceFiles: 'pipeline.yml')], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])
            }
        }  
```

##### 执行k8s远端脚本

1. ssh免密登录

jenkins容器内能够直接执行k8smaster主机上的脚本

```shell
#jenkins容器生成公钥
docker exec -it jenkins bash
ssh-keygen -t rsa
cat id_rsa.pub
#把公钥放到k8smaster上
ssh-keygen -t rsa
cd .ssh
touch authorized_keys
#把公钥拷贝到这个文件中
```

2. 执行脚本

生成脚本

```
ssh root@192.168.210.20 kubectl apply -f /usr/local/k8s/pipeline.yml
```

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220507095457.png)

pipeline.yml中新增步骤

```
        stage('执行远程k8smaster的kubectl命令') {
            steps {
                sh 'ssh root@192.168.210.20 kubectl apply -f /usr/local/k8s/pipeline.yml'
            }
        }
```

#### 自动化ci操作

1. 下载gitlab插件
2. 配置gitlab hook信息

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220507112905.png)

3. hook信息在gitlab中配置

```
http://192.168.210.10:8099/project/pipeline
```

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220507113312.png)

> Url is blocked: Requests to the local network are not allowed

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220507113723.png)

>   Hook executed successfully but returned HTTP 403 <html> <head> <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/> <title>Error 403 anonymous is missing the Job/Build permission</title> </head> <body><h2>HTTP ERROR 403 anonymous is missing the Job/Build permission</h2> <table> <tr><th>URI:</th><td>/project/pipeline</td></tr> <tr><th>STATUS:</th><td>403</td></tr> <tr><th>MESSAGE:</th><td>anonymous is missing the Job/Build permission</td></tr> <tr><th>SERVLET:</th><td>Stapler</td></tr> </table> <hr><a href="https://eclipse.org/jetty">Powered by Jetty:// 9.4.43.v20210629</a><hr/> </body> </html>

jenkins 系统管理-》 系统配置

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220507114627.png)

4. 去掉参数化构建

![](https://cdn.jsdelivr.net/gh/dong-jianbin/drawing-bed/mall/20220507115330.png)

jenkinsfile文件中的tag变量替换掉

5. k8s 代码变动就构建，解决unchangge

jenkinsfile修改

```
        stage('执行远程k8smaster的kubectl命令') {
            steps {
                sh '''ssh root@192.168.210.20 kubectl apply -f /usr/local/k8s/pipeline.yml
                ssh root@192.168.210.20 kubectl rollout restart deployment pipeline -n test'''
            }
        }
```

